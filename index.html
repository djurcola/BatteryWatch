<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battery Watch</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”‹</text></svg>" type="image/svg+xml">
    <style>
        /* --- Dark Theme CSS --- */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #383838;
            --chart-area-bg: #333333;
            --border-color: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --accent-primary: #007bff;
            --accent-hover: #0056b3;
            --disabled-bg: #555555;
            --disabled-text: #999999;
            --error-color: #f44336;
            --chart-grid-color: rgba(255, 255, 255, 0.15);
            --zero-line-color: rgba(255, 255, 255, 0.3);
            --chart-line-grey: #B0BEC5;
            --discharge-point-color: #64B5F6; /* Adjusted for dark theme visibility */
            --charge-point-color: #1976D2; /* Adjusted for dark theme visibility */
			--link-color: #5dade2; /* Light blue for links */
			--card-border: var(--border-color); /* Use border color for card outlines */
			--edge-padding: 20px; /* Consistent padding for sections */
        }

        body {
            font-family: sans-serif;
            padding: 15px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.95em;
        }
        .container {
            /*max-width: 1200px;*/
            margin: 0 auto;
            /*background-color: var(--bg-secondary);*/ /* Container doesn't need background */
            padding: 0; /* Container doesn't need padding */
            border-radius: 8px;
            /*box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);*/ /* Shadow on inner sections */
            /*border: 1px solid var(--border-color);*/ /* Border on inner sections */
        }

        /* --- Centering --- */
        .header-section {
             text-align: center;
             margin-bottom: 25px;
        }
        .header-section h1 {
            margin-bottom: 5px;
        }
        .header-section p {
             margin-top: 0;
        }
        /* --- End Centering --- */

        h1, h2 { /* Removed unused h3 style */
            color: var(--text-primary);
        }
        p {
            color: var(--text-secondary);
        }

        .chart-container {
            position: relative;
            margin: 20px 0;
            height: 55vh;
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Added subtle shadow */
            border: 1px solid var(--border-color);
        }
        .chart-container canvas {
             background-color: var(--chart-area-bg);
             border-radius: 3px;
             display: block;
             width: 100% !important;
             height: 100% !important;
        }

        .control-section {
            background-color: var(--bg-secondary);
            padding: var(--edge-padding); /* Use consistent padding */
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid var(--card-border); /* Use consistent border */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Added subtle shadow */
        }
        .control-section h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px 20px;
            align-items: center;
			justify-content: center;
        }
		.control-group {
			 margin-bottom: 10px;
			 display: flex;         /* ADD: Make this a flex container */
			 align-items: center;   /* ADD: Vertically align items in the center */
			 /* flex-wrap: nowrap; */ /* Optional: Add if items still wrap unexpectedly */
			 justify-content: center;
		}
		.control-group label {
			display: inline-block;
			margin-right: 8px;
			font-weight: bold;
			min-width: 80px; /* Keep this for consistent label width */
			color: var(--text-primary);
			vertical-align: middle; /* ADD or ENSURE this line exists */
		 }
		.control-group input[type="datetime-local"],
		 .control-group select {
			padding: 6px 8px;
			border: 1px solid var(--border-color);
			border-radius: 3px;
			box-sizing: border-box;
			background-color: var(--bg-tertiary);
			color: var(--text-primary);
			width: auto; /* Keep width auto */
			max-width: 250px; /* Adjust max-width if needed for longer names */
			vertical-align: middle; /* ADD or ENSURE this line exists */
		}
		
		#relativeTimeControls {
			display: flex !important;     /* Use !important to override inline style */
			align-items: center !important; /* Ensure vertical alignment */
            justify-content: center; /* Center content within flex */
		}
        .control-group input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(1); /* Make calendar icon visible in dark mode */
        }
        .control-group select {
            width: auto;
            max-width: 250px; /* Ensure consistency */
        }
        /* Removed unused checkbox style */

        /* Base button style (kept for potential future use, e.g., inside controls) */
        button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--accent-primary);
            color: white;
            margin: 5px;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            cursor: not-allowed;
        }
        /* Removed unused action-buttons styles */

        .status-and-loading {
            text-align: center;
            /*margin-top: 15px;*/
            min-height: 1.2em; /* Reserve space */
			margin-bottom: 10px;
             /* ADD for grid alignment if needed */
             display: flex;
             align-items: center;
             justify-content: center;
        }
        #status {
             font-style: italic;
             color: var(--text-secondary);
             display: inline-block; /* Use inline-block for better alignment */
         }
        #status[style*="color: var(--error-color)"] { /* Check against CSS variable */
             color: var(--error-color) !important;
        }
        #loadingSpinner {
            display: none; /* Controlled by JS */
            font-weight: bold;
            color: var(--accent-primary);
            margin-left: 10px;
             display: inline-block; /* Use inline-block */
             vertical-align: middle; /* Align with text */
        }
        #actualRangeDisplay {
            text-align: center;
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 5px;
            min-height: 1.1em;
        }

        /* Style for Zoom Instructions */
        .zoom-instructions {
            text-align: center;
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: -10px;
            margin-bottom: 15px;
        }

        /* Shared styles for both info containers */
        #generatorInfoContainer,
        #allBatteryInfoContainer {
            /* Uses existing .control-section styles */
             margin-top: 20px; /* Add space above the info section */
        }

        #generatorInfoContent table,
        #allBatteryInfoContent table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        #generatorInfoContent th,
        #generatorInfoContent td,
        #allBatteryInfoContent th,
        #allBatteryInfoContent td {
            border: 1px solid var(--border-color);
            padding: 8px 10px;
            text-align: left;
            font-size: 0.9em;
        }

        #generatorInfoContent th,
        #allBatteryInfoContent th {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
            width: 35%; /* Adjust width as needed */
        }

        #generatorInfoContent td,
        #allBatteryInfoContent td {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
        }
		/* --- Footer Styling --- */
		footer {
			margin-top: 20px;       /* Space above the footer */
			padding: 20px var(--edge-padding); /* Vertical padding + Respect horizontal edge padding */
			border-top: 1px solid var(--card-border); /* Subtle divider using theme border color */
			text-align: center;      /* Center the text content */
			font-size: 0.9em;        /* Slightly smaller than base text */
			color: var(--text-secondary); /* Use the dimmer text color for less emphasis */
			/* Inherits background-color from body */
			/* Transition for smooth theme changes */
			transition: border-color 0.3s ease, color 0.3s ease;
		}
		footer p {
			margin: 0; /* Remove default paragraph margin */
		}

		footer a {
			color: var(--link-color); /* Use the theme's link color */
			text-decoration: none;   /* Remove default underline */
			font-weight: 500;        /* Slightly bolder link */
			transition: color 0.2s ease; /* Smooth hover effect */
		}

		footer a:hover,
		footer a:focus {
			color: var(--link-color); /* Keep color, or adjust if desired */
			text-decoration: underline; /* Add underline on hover/focus for accessibility */
			opacity: 0.85; /* Optional: Slight fade effect on hover */
		}

    </style>
</head>
<body>

<div class="container">
    <div class="header-section">
        <h1>Battery Watch</h1>
        <p>Explore historical power output and battery details.</p>
        <p>The "Generator" selector below lists dispatching batteries used for the chart. The "Battery Info" selector lists all batteries found in the metadata file.</p>
    </div>

    <!-- Generator/Chart Controls -->
    <div class="control-section">
        <h2>Chart Controls</h2>
        <div class="control-grid">
            <!-- Battery Selector (for Chart) -->
            <div class="control-group">
                 <label for="tagValue">Generator (Chart):</label>
                 <select id="tagValue">
                     <option value="">Loading...</option>
                 </select>
            </div>
			<!-- Status/Loading for Chart -->
			<div class="status-and-loading">
				<span id="status">Select a Generator to load chart data.</span>
				<span id="loadingSpinner"></span>
			</div>
            <!-- Relative Time Controls (Always Visible - styled as a grid item) -->
            <div id="relativeTimeControls" class="control-group">
                <label for="timeRange">Time Range:</label>
                <select id="timeRange">
                    <option value="1h">Last 1 Hour</option>
                    <option value="6h">Last 6 Hours</option>
                    <option value="12h">Last 12 Hours</option>
                    <option value="24h" selected>Last 24 Hours</option>
                    <option value="7d">Last 7 Days</option>
                    <option value="30d">Last 30 Days</option>
                </select>
            </div>

            <!-- Time Range Mode (HIDDEN but present for JS) -->
            <div style="display: none;"> <!-- Hide this whole div -->
                 <label><input type="radio" name="timeRangeMode" value="relative" checked> Relative</label>
                 <label><input type="radio" name="timeRangeMode" value="absolute"> Absolute</label>
            </div>

            <!-- Absolute Time Controls (HIDDEN but present for JS) -->
            <div id="absoluteTimeControls" style="display: none;"> <!-- Hide this whole div -->
                <div class="control-grid"> <!-- Nested grid still useful if shown -->
                    <div class="control-group">
                        <label for="startTime">Start Time:</label>
                        <input type="datetime-local" id="startTime">
                    </div>
                    <div class="control-group">
                         <label for="endTime">End Time:</label>
                        <input type="datetime-local" id="endTime">
                    </div>
                 </div>
                 <p style="text-align: center; font-size: 0.85em; color: var(--text-secondary); margin-top: 5px;">(Times use your browser's local timezone)</p>
            </div>
        </div> <!-- End control-grid -->
    </div> <!-- End Generator/Chart Controls -->

    <!-- Chart Display Area -->
    <div class="chart-container">
        <canvas id="powerChart"></canvas>
    </div>
    <p class="zoom-instructions">
        Tip: Double-click chart to reset zoom. Hold Ctrl + Drag to select zoom area. Use scroll wheel/pinch to zoom.<br>
        Zooming/panning will fetch data for the new visible range.
    </p>
    <div id="actualRangeDisplay" style="display: none;"></div><!-- Hide this whole div -->

    <!-- Generator Info Section (Linked to Chart Generator) -->
    <div id="generatorInfoContainer" class="control-section" style="display: none;">
        <h2>Selected Generator Information</h2>
        <div id="generatorInfoContent">
            <!-- Content will be populated by JS -->
            <p>Loading generator details...</p>
        </div>
    </div>

    <div class="header-section">
        <h1>Battery Info</h1>
        <p>Explore details of all current and future batteries in the NEM.</p>
    </div>
    <!-- New Battery Info Section (Linked to JSON Battery Select) -->
     <div class="control-section" style="margin-top: 20px;">
        <h2>Committed Battery Information (includes operating and future)</h2>
        <div class="control-grid">
            <!-- Battery Selector (from JSON) -->
             <div class="control-group">
                <label for="batteryInfoSelect">Battery (Info):</label>
                <select id="batteryInfoSelect">
                     <option value="">Loading Battery List...</option>
                </select>
            </div>
            <!-- Optional: Status/Loading for Battery Info Select -->
             <div class="status-and-loading">
                 <span id="batteryInfoStatus">Select a Battery for details.</span>
                 <span id="batteryInfoLoadingSpinner" style="display: none;"></span>
             </div>
        </div>
         <!-- Content will be populated by JS -->
        <div id="allBatteryInfoContent">
             <p style="text-align: center; color: var(--text-secondary);">Details will appear here after selection.</p>
        </div>
     </div>
    <!-- End New Battery Info Section -->


</div> <!-- End Container -->

    <footer>
      <p>
        Made by Daniel Jurcola,
        <a href="https://www.linkedin.com/in/djurcola/" target="_blank" rel="noopener noreferrer">get in touch!</a>
      </p>
    </footer>


    <!-- Include Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <script>
        // --- UI Elements ---
        const generatorSelect = document.getElementById('tagValue'); // For chart
        const timeRangeModeRadios = document.querySelectorAll('input[name="timeRangeMode"]');
        const relativeTimeControls = document.getElementById('relativeTimeControls');
        const absoluteTimeControls = document.getElementById('absoluteTimeControls');
        const timeRangeSelect = document.getElementById('timeRange');
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');

        const statusDiv = document.getElementById('status'); // For chart data loading
        const loadingSpinner = document.getElementById('loadingSpinner'); // For chart data loading

        const actualRangeDisplay = document.getElementById('actualRangeDisplay');

		const generatorInfoContainer = document.getElementById('generatorInfoContainer'); // Info linked to chart generator
		const generatorInfoContent = document.getElementById('generatorInfoContent'); // Info linked to chart generator

        const batteryInfoSelect = document.getElementById('batteryInfoSelect'); // NEW: For battery metadata info
        const batteryInfoStatus = document.getElementById('batteryInfoStatus'); // NEW: Status for battery info loading
        const batteryInfoLoadingSpinner = document.getElementById('batteryInfoLoadingSpinner'); // NEW: Loading for battery info
        const allBatteryInfoContent = document.getElementById('allBatteryInfoContent'); // NEW: Info content for any battery

        // --- CSS Variables ---
        const cssRoot = document.documentElement;
        const themeColors = {
            textPrimary: getComputedStyle(cssRoot).getPropertyValue('--text-primary').trim(),
            textSecondary: getComputedStyle(cssRoot).getPropertyValue('--text-secondary').trim(),
            chartGridColor: getComputedStyle(cssRoot).getPropertyValue('--chart-grid-color').trim(),
            zeroLineColor: getComputedStyle(cssRoot).getPropertyValue('--zero-line-color').trim(),
            chartLineGrey: getComputedStyle(cssRoot).getPropertyValue('--chart-line-grey').trim(),
            dischargePointColor: getComputedStyle(cssRoot).getPropertyValue('--discharge-point-color').trim(),
            chargePointColor: getComputedStyle(cssRoot).getPropertyValue('--charge-point-color').trim(),
			errorColor: getComputedStyle(cssRoot).getPropertyValue('--error-color').trim(), // Get error color CSS var
        };

        // --- State Variables ---
        const ZOOM_PAN_DEBOUNCE_MS = 250;
		let batteryMetadataMap = new Map(); // To store BatteryData.json keyed by DUID (for generator info)
		let allBatteryDataArray = []; // NEW: To store the full BatteryData.json array (for battery info select)


        // --- Helper Functions ---
        // showLoading and updateStatus now only refer to chart data loading
        function showLoading(isLoading, operation = "data") {
            loadingSpinner.textContent = isLoading ? `Loading ${operation}...` : '';
            loadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
        }

        function updateStatus(message, isError = false, target = 'chart') {
             const statusElement = target === 'chart' ? statusDiv : batteryInfoStatus;
             const color = isError ? themeColors.errorColor : themeColors.textSecondary;
             statusElement.textContent = message;
             statusElement.style.color = color;
             if (isError) console.error(`Status Update (${target} Error):`, message);
         }

        // NEW: Loading/Status for battery info section
        function showBatteryInfoLoading(isLoading) {
             batteryInfoLoadingSpinner.textContent = isLoading ? 'Loading list...' : '';
             batteryInfoLoadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
        }

        // Debounce function (unchanged)
        function debounce(func, wait) {
            let timeout;
            const debounced = function executedFunction(...args) {
                const context = this;
                const later = () => {
                    timeout = null;
                    func.apply(context, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
            debounced.cancel = function() {
                clearTimeout(timeout);
                timeout = null;
            };
            return debounced;
        }
        // --- End Helper Functions ---

        // --- Chart.js Setup ---
        const ctx = document.getElementById('powerChart').getContext('2d');
        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Generator Output (MW)',
                    data: [],
                    borderColor: themeColors.chartLineGrey,
                    borderWidth: 2.5,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: (context) => {
                        const y = context.raw?.y;
                        if (y === null || y === undefined) return 'rgba(128, 128, 128, 0.5)'; // Grey for null/undefined
                        return y < 0 ? themeColors.chargePointColor : themeColors.dischargePointColor; // Charge/Discharge colors
                    },
                    pointBorderColor: (context) => {
                         const y = context.raw?.y;
                         if (y === null || y === undefined) return 'rgba(128, 128, 128, 0.8)'; // Grey border
                         return y < 0 ? themeColors.chargePointColor : themeColors.dischargePointColor; // Charge/Discharge colors
                    },
                    pointBorderWidth: 1,
                    //tension: 0.1, // Removed for stepped line
		            stepped: 'before',	// Use 'before' for stepped line
                    fill: false,
                    spanGaps: false, // Do not draw lines across missing data
                }]
             },
            options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 scales: {
                    x: {
                        type: 'time',
                        title: { display: true, text: 'Time', color: themeColors.textPrimary },
                        grid: { color: themeColors.chartGridColor },
                        ticks: { color: themeColors.textPrimary, major: { enabled: true } },
                        time: { // Define desired time formats
                            tooltipFormat: 'MMM d, yyyy HH:mm:ss', // Example format
                             displayFormats: {
                                millisecond: 'HH:mm:ss.SSS',
                                second: 'HH:mm:ss',
                                minute: 'HH:mm',
                                hour: 'HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy',
                                quarter: 'QQQ yyyy',
                                year: 'yyyy'
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Output (MW)', color: themeColors.textPrimary },
                        grid: { color: themeColors.chartGridColor },
                        ticks: { color: themeColors.textPrimary }
                    }
                 },
                 plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    title: {
                        display: true,
                        text: 'Battery Power Output', // Default title
                        font: { size: 16 },
                        color: themeColors.textPrimary
                    },
                    legend: {
                        display: true,
                        labels: { color: themeColors.textPrimary }
                    },
                    zoom: { // Zoom/Pan configuration
                        pan: {
                            enabled: true,
                            mode: 'x',
                            threshold: 5,
                            onPanComplete: ({chart}) => {
                                console.log("Pan complete");
                                debouncedZoomPanFetch(chart);
                            }
                        },
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            drag: {
                                enabled: true,
                                borderColor: 'rgba(173, 216, 230, 0.6)',
                                borderWidth: 1,
                                backgroundColor: 'rgba(173, 216, 230, 0.2)',
                                modifierKey: 'ctrl'
                            },
                            mode: 'x',
                            onZoomComplete: ({chart}) => {
                                console.log("Zoom complete");
                                debouncedZoomPanFetch(chart);
                            }
                        }
                    },
					annotation: { // Annotation configuration
                        annotations: {
                            zeroLine: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: themeColors.zeroLineColor,
                                borderWidth: 1.5,
                                borderDash: [6, 6],
                                label: {
                                    content: '0 MW',
                                    position: 'start',
                                    enabled: true,
                                    color: themeColors.textSecondary,
                                    font: { size: 10 },
                                    yAdjust: -5
                                }
                            }
                        }
                    }
                 },
                 interaction: { // Interaction configuration
                     mode: 'nearest',
                     axis: 'x',
                     intersect: false
                 }
            }
        };
        const powerChart = new Chart(ctx, chartConfig);

        // --- Double Click Reset Listener ---
        if (powerChart && powerChart.canvas) {
            powerChart.canvas.addEventListener('dblclick', () => {
                console.log("Chart canvas double-clicked - Resetting zoom and fetching initial range data.");
                powerChart.resetZoom(); // Reset zoom state

                // Cancel any pending zoom/pan fetch that might have been queued by the resetZoom()
                debouncedZoomPanFetch.cancel();
                console.log("Cancelled any pending zoom/pan fetch due to reset.");

                // Fetch data based on UI controls after resetting zoom
                updateChartWithApiData(true); // Pass flag to indicate explicit reset
            });
        } else {
            console.error("Could not attach double-click listener: Chart or canvas not ready.");
        }

        // --- API Communication ---
        const API_BASE_URL = 'https://backend.danjurcola.com/api';
        const API_GENERATORS_ENDPOINT = `${API_BASE_URL}/generators`;
        const API_QUERY_ENDPOINT = `${API_BASE_URL}/query`;
		const BATTERY_DATA_URL = './BatteryData.json';

		async function fetchBatteryMetadata() {
			console.log("Fetching battery metadata...");
			// Use the NEW battery info status/loading for this specific fetch
			updateStatus("Loading battery list...", false, 'batteryInfo');
			showBatteryInfoLoading(true);

			try {
				const response = await fetch(BATTERY_DATA_URL);
				if (!response.ok) {
					throw new Error(`HTTP error ${response.status} fetching ${BATTERY_DATA_URL}`);
				}
				const batteryDataArray = await response.json();

				if (Array.isArray(batteryDataArray)) {
					allBatteryDataArray = batteryDataArray; // Store the full array
					batteryMetadataMap.clear(); // Clear previous DUID map data

					// Populate the DUID map (used for the generator info section)
					batteryDataArray.forEach(item => {
						if (item.DUID && typeof item.DUID === 'string' && item.DUID.trim() !== '') {
							batteryMetadataMap.set(item.DUID.trim(), item);
						}
					});

                    // Sort the array by Site Name for the new dropdown
                    allBatteryDataArray.sort((a, b) => {
                         const nameA = a['Site Name'] || ''; // Handle null/undefined
                         const nameB = b['Site Name'] || '';
                         return nameA.localeCompare(nameB);
                    });

					console.log(`Successfully loaded ${allBatteryDataArray.length} battery metadata entries. Mapped ${batteryMetadataMap.size} by DUID.`);
					updateStatus("Battery list loaded.", false, 'batteryInfo'); // Update battery info status
					// Status for chart generator dropdown loading is handled elsewhere
				} else {
					throw new Error("Battery metadata file did not contain a valid JSON array.");
				}
			} catch (error) {
				console.error("Error fetching or processing battery metadata:", error);
				updateStatus(`Error loading battery list: ${error.message}`, true, 'batteryInfo'); // Update battery info status on error
				allBatteryDataArray = []; // Ensure array is empty on error
				batteryMetadataMap.clear(); // Ensure map is empty on error
			} finally {
                 showBatteryInfoLoading(false); // Hide battery info loading spinner
            }
		}

		// This function now displays info based on the Generator (DUID) selection
		function displayGeneratorInfo(generatorDUID) {
			if (!generatorDUID) {
				generatorInfoContainer.style.display = 'none'; // Hide if no generator selected
				generatorInfoContent.innerHTML = ''; // Clear content
				return;
			}
			const batteryData = batteryMetadataMap.get(generatorDUID);
			if (batteryData) {
				console.log("Found generator data for DUID:", generatorDUID, batteryData);
				// Select the fields you want to display
				const fieldsToShow = {
					'Site Name': 'Site Name',
					'Owner': 'Owner',
					'Region': 'Region',
					'Status': 'Unit Status',
					'Nameplate Capacity (MW)': 'Nameplate Capacity (MW)',
					'Storage Capacity (MWh)': 'Storage Capacity (MWh)',
					'Commercial Use Date': 'Full Commercial Use Date',
					'Battery Manufacturer': 'Battery Manufacturer',
					'Battery Model': 'Battery Model',
					'Inverter Manufacturer': 'Inverter Manufacturer',
					'Inverter Model': 'Inverter Model',
                    'Dispatch Type': 'Dispatch Type' // Added this field
				};
				let tableHTML = '<table><tbody>';
				for (const [label, key] of Object.entries(fieldsToShow)) {
					const value = batteryData[key] !== null && batteryData[key] !== undefined && batteryData[key] !== '' ? batteryData[key] : 'N/A';
					tableHTML += `<tr><th>${label}</th><td>${value}</td></tr>`;
				}
				tableHTML += '</tbody></table>';
				generatorInfoContent.innerHTML = tableHTML;
				generatorInfoContainer.style.display = 'block'; // Show the container
			} else {
				console.log("No generator metadata found for DUID:", generatorDUID);
				generatorInfoContent.innerHTML = '<p>No additional generator information found for this DUID.</p>';
				generatorInfoContainer.style.display = 'block'; // Show the container with the message
			}
		}

        // NEW: This function displays info based on the Battery Info (Site Name) selection
        function displayAllBatteryInfo(siteName) {
             allBatteryInfoContent.innerHTML = ''; // Clear previous content

             if (!siteName) {
                 allBatteryInfoContent.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Details will appear here after selection.</p>';
                 updateStatus("Select a Battery for details.", false, 'batteryInfo'); // Reset battery info status
                 return;
             }

             updateStatus(`Looking up details for ${siteName}...`, false, 'batteryInfo');

             const selectedBattery = allBatteryDataArray.find(item => item['Site Name'] === siteName);

             if (selectedBattery) {
                 console.log("Found battery data for Site Name:", siteName, selectedBattery);
                 const fieldsToShow = { // Use the same set of fields for consistency
                    'Region': 'Region',
                    'Asset Type': 'Asset Type',
					'Site Name': 'Site Name',
					'Owner': 'Owner',
					'Technology Type': 'Technology Type',
                    'Fuel Type': 'Fuel Type',
                    'DUID': 'DUID',
					'Status': 'Unit Status',
					'Nameplate Capacity (MW)': 'Nameplate Capacity (MW)',
					'Storage Capacity (MWh)': 'Storage Capacity (MWh)',
					'Commercial Use Date': 'Full Commercial Use Date',
					'Battery Manufacturer': 'Battery Manufacturer',
					'Battery Model': 'Battery Model',
					'Inverter Manufacturer': 'Inverter Manufacturer',
					'Inverter Model': 'Inverter Model',
                    'Dispatch Type': 'Dispatch Type',
                    'Status Bucket Summary': 'Status Bucket Summary',
                    'Fuel Bucket Summary': 'Fuel Bucket Summary'
                 };
                 let tableHTML = '<table><tbody>';
                 for (const [label, key] of Object.entries(fieldsToShow)) {
                     const value = selectedBattery[key] !== null && selectedBattery[key] !== undefined && selectedBattery[key] !== '' ? selectedBattery[key] : 'N/A';
                     tableHTML += `<tr><th>${label}</th><td>${value}</td></tr>`;
                 }
                 tableHTML += '</tbody></table>';
                 allBatteryInfoContent.innerHTML = tableHTML;
                 updateStatus(`Details displayed for ${siteName}.`, false, 'batteryInfo'); // Update battery info status
             } else {
                 console.warn("No battery data found for Site Name:", siteName);
                 allBatteryInfoContent.innerHTML = '<p style="text-align: center; color: var(--error-color);">Could not find details for this battery in the metadata.</p>';
                 updateStatus(`Details not found for ${siteName}.`, true, 'batteryInfo'); // Update battery info status on error
             }
         }


		async function fetchGeneratorTags() {
            // Status update for generator list fetching
            updateStatus("Fetching generator list...", false, 'chart'); // Chart status
            showLoading(true, "generators"); // Chart loading spinner

            try {
                const response = await fetch(API_GENERATORS_ENDPOINT);
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status} ${response.statusText}`);
                }
                const generatorList = await response.json();

                if (Array.isArray(generatorList)) {
                    console.log("Fetched generator DUID list:", generatorList.length, "items");
                    // Just return the list, filtering out empty values and sorting
                    return generatorList.filter(genName => genName).sort();
                } else {
                    throw new Error("API response for generators was not an array.");
                }
            } catch (error) {
                console.error("Error fetching generator tags:", error);
                updateStatus(`Error fetching generators: ${error.message}`, true, 'chart'); // Chart status on error
                // Return null or an empty array to signal failure
                return null;
            } finally {
                // showLoading(false); // Loading is handled globally in DOMContentLoaded
            }
        }

        // Fetch Function for specific time range (used by zoom/pan)
        async function fetchDataForRange(generator, startTimeIso, endTimeIso) {
            if (!generator || !startTimeIso || !endTimeIso) {
                console.warn("fetchDataForRange called with missing parameters.");
                updateStatus("Internal error: Missing range parameters.", true, 'chart'); // Chart status
                return null;
            }

            const params = new URLSearchParams({
                generator: generator,
                timeMode: 'absolute', // Always use absolute for direct range fetches
                start: startTimeIso,
                end: endTimeIso
            });

            const queryUrl = `${API_QUERY_ENDPOINT}?${params.toString()}`;
            console.log(`Requesting data for specific range: ${queryUrl}`);
            showLoading(true, "data"); // Chart loading
            updateStatus(`Fetching data for range...`, false, 'chart'); // Chart status

            try {
                const response = await fetch(queryUrl);
                 if (!response.ok) {
                     let errorDetail = `API Error: ${response.status} ${response.statusText}`;
                    try {
                        const errData = await response.json();
                        errorDetail += ` - ${errData.error || JSON.stringify(errData)}`;
                    } catch(e) { /* Ignore if response body isn't JSON */ }
                    throw new Error(errorDetail);
                }
                const apiData = await response.json();

                if (!Array.isArray(apiData)) {
                     throw new Error("API response for data was not an array.");
                }

                // Transform data for Chart.js {x: Date, y: number}
                const chartData = apiData.map(point => ({
                    x: new Date(point.x),
                    y: point.y
                })).filter(p => !isNaN(p.x.getTime())); // Filter out points with invalid dates

                updateStatus(`Data loaded: ${chartData.length} points for the range.`, false, 'chart'); // Chart status
                displayActualRange(chartData); // Update the range display text

                return chartData; // Success

            } catch (error) {
                console.error('API Fetch Error (fetchDataForRange):', error);
                updateStatus(`Error fetching data for range: ${error.message}`, true, 'chart'); // Chart status on error
                actualRangeDisplay.textContent = ''; // Clear range display on error
                return null; // Indicate failure
            } finally {
                showLoading(false); // Hide chart loading indicator
            }
        }

        // Fetch data based on UI controls (Relative/Absolute Time)
        async function fetchDataFromApi() {
            const selectedGenerator = generatorSelect.value;
            const timeMode = document.querySelector('input[name="timeRangeMode"]:checked').value;

            actualRangeDisplay.textContent = ''; // Clear previous range display
            showLoading(true); // Chart loading
            updateStatus("Fetching data based on controls...", false, 'chart'); // Chart status

            if (!selectedGenerator) {
                 updateStatus("Error: Please select a Generator.", true, 'chart'); // Chart status
                 showLoading(false); // Chart loading
                 return null;
            }

            const params = new URLSearchParams({
                 generator: selectedGenerator,
                 timeMode: timeMode
            });
            let startIso, endIso; // Define here for absolute mode

            if (timeMode === 'relative') {
                const range = timeRangeSelect.value;
                if (!range) {
                    updateStatus("Error: Invalid relative range selected.", true, 'chart'); // Chart status
                    showLoading(false); // Chart loading
                    return null;
                }
                params.append('range', range);
            } else { // Absolute time
                const start = startTimeInput.value;
                const end = endTimeInput.value;
                if (!start || !end) {
                     updateStatus("Error: Please select both Start and End times.", true, 'chart'); // Chart status
                     showLoading(false); // Chart loading
                     return null;
                }
                try {
                    // Convert local datetime-local input to ISO strings for the API
                    startIso = new Date(start).toISOString();
                    endIso = new Date(end).toISOString();
                    params.append('start', startIso);
                    params.append('end', endIso);
                } catch (e) {
                     updateStatus("Error: Invalid date format entered.", true, 'chart'); // Chart status
                     showLoading(false); // Chart loading
                     console.error("Error parsing absolute dates:", e);
                     return null;
                }
            }

            const queryUrl = `${API_QUERY_ENDPOINT}?${params.toString()}`;
            console.log(`Requesting data from API (UI controls): ${queryUrl}`);

            try {
                const response = await fetch(queryUrl);
                 if (!response.ok) {
                     let errorDetail = `API Error: ${response.status} ${response.statusText}`;
                    try {
                        const errData = await response.json();
                        errorDetail += ` - ${errData.error || JSON.stringify(errData)}`;
                    } catch(e) { /* Ignore */ }
                    throw new Error(errorDetail);
                }
                const apiData = await response.json();

                if (!Array.isArray(apiData)) {
                     throw new Error("API response for data was not an array.");
                }

                // Transform data for Chart.js
                const chartData = apiData.map(point => ({
                    x: new Date(point.x),
                    y: point.y
                })).filter(p => !isNaN(p.x.getTime()));

                updateStatus(`Chart data loaded: ${chartData.length} points.`, false, 'chart'); // Chart status
                displayActualRange(chartData); // Update the range display text

                return chartData; // Success

            } catch (error) {
                console.error('API Fetch Error (fetchDataFromApi):', error);
                updateStatus(`Error fetching chart data: ${error.message}`, true, 'chart'); // Chart status on error
                actualRangeDisplay.textContent = '';
                return null; // Indicate failure
            } finally {
                 showLoading(false); // Hide chart loading
            }
        }

        // Helper to update the actual range display text
        function displayActualRange(chartData) {
            const displayElement = actualRangeDisplay; // Ensure we are targeting the chart range display
            if (chartData && chartData.length > 0) {
                 const firstPoint = chartData[0];
                 const lastPoint = chartData[chartData.length - 1];
                 // Check if points and their dates are valid
                 if (firstPoint?.x instanceof Date && !isNaN(firstPoint.x.getTime()) &&
                     lastPoint?.x instanceof Date && !isNaN(lastPoint.x.getTime()))
                 {
                     const formatConfig = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' };
                     // Display range based on actual data points returned
                     displayElement.textContent = `Data displayed from: ${firstPoint.x.toLocaleString(undefined, formatConfig)} to ${lastPoint.x.toLocaleString(undefined, formatConfig)}`;
                     displayElement.style.display = 'block'; // Show the range display
                 } else {
                      displayElement.textContent = 'Could not determine data range from points.';
                      displayElement.style.display = 'block'; // Show even if determination fails
                      console.warn("displayActualRange: Invalid date found in first/last point", firstPoint, lastPoint);
                 }
            } else {
                displayElement.textContent = 'No data returned for this period.';
                displayElement.style.display = 'block'; // Show message even if no data
            }
        }

        // Updates chart based on UI controls, optionally resetting zoom
        async function updateChartWithApiData(isReset = false) {
            const chartData = await fetchDataFromApi(); // Fetch based on UI

            if (!powerChart) { // Guard against chart not being ready
                console.error("updateChartWithApiData called before chart was initialized.");
                return;
            }

            const selectedGenerator = generatorSelect.value;
            powerChart.options.plugins.title.text = `Battery Power: ${selectedGenerator || 'N/A'}`; // Update title immediately

            if (chartData !== null) { // Check if fetch was successful (returned data or empty array)
                powerChart.data.datasets[0].data = chartData;
				powerChart.data.datasets[0].label = `Output (MW)`; // Keep label simple
                // Check if the currently selected generator is actually a battery and has metadata
                displayGeneratorInfo(selectedGenerator); // Update the generator info section based on the DUID

                // Reset zoom ONLY when called from UI changes/explicit reset, OR if not currently zoomed/panned AND data was returned
                if (isReset || (!powerChart.isZoomedOrPanned() && chartData.length > 0)) {
                    console.log("Resetting chart zoom to fit fetched data.");
                    delete powerChart.options.scales.x.min; // Let Chart.js auto-scale
                    delete powerChart.options.scales.x.max;
                } else {
                    console.log("Maintaining current chart zoom level after UI-triggered fetch.");
                }

                powerChart.update(); // Use default update animation for UI-triggered changes
            } else {
                // Fetch failed (returned null) or empty data array returned by successful fetch
                 console.log("Clearing chart data due to fetch error or empty data.");
                 powerChart.data.datasets[0].data = [];
                 // Always reset zoom on error/no data to avoid being stuck in an invalid range
                 delete powerChart.options.scales.x.min;
                 delete powerChart.options.scales.x.max;
                 powerChart.update();
                 // displayGeneratorInfo is already called above and will show 'No info' if DUID not found or data is null.
                 // The status message is updated by fetchDataFromApi on error.
            }
             // The range display is updated by displayActualRange or cleared on error.
        }

        // Handles fetching data when zoom or pan completes.
        async function handleZoomPanFetch(chart) {
            const selectedGenerator = generatorSelect.value;
            if (!selectedGenerator) {
                console.log("Zoom/Pan fetch skipped: No generator selected.");
                updateStatus("Select a Generator to enable zooming.", false, 'chart'); // Inform user
                return;
            }

            // --- Step 1: Read initial scales ---
            if (!chart?.scales?.x) {
                 console.error("handleZoomPanFetch Error: Chart scales object is not available.");
                 updateStatus("Internal chart error.", true, 'chart'); // Chart status
                 return;
            }
            const { min: initialTargetMin, max: initialTargetMax } = chart.scales.x;

            // Validate initial scales read from the event
            if (initialTargetMin === undefined || initialTargetMax === undefined || typeof initialTargetMin !== 'number' || typeof initialTargetMax !== 'number' || isNaN(initialTargetMin) || isNaN(initialTargetMax)) {
                 console.warn("Zoom/Pan fetch skipped: Could not read valid min/max numbers from chart scales.", initialTargetMin, initialTargetMax);
                 // Don't set error status, as this can sometimes happen briefly during chart transitions
                 return;
            }
            if (initialTargetMin >= initialTargetMax) {
                console.warn("Zoom/Pan fetch skipped: Invalid initial target time range (min >= max).", initialTargetMin, initialTargetMax);
                 // Don't set error status
                return;
            }

            // --- Step 2: Containment/Future Zoom Check ---
            let needsFetch = true; // Assume fetch needed unless logic says otherwise
            const currentData = chart.data.datasets[0].data;

            if (currentData && currentData.length > 1) {
                let dataMinTimestamp = Infinity;
                let dataMaxTimestamp = -Infinity;
                let validDataRangeFound = false;

                // Find the actual min/max timestamps in the *currently displayed* data
                currentData.forEach(point => {
                    if (point?.x instanceof Date && !isNaN(point.x.getTime()) && isFinite(point.x.getTime())) {
                        const time = point.x.getTime();
                        dataMinTimestamp = Math.min(dataMinTimestamp, time);
                        dataMaxTimestamp = Math.max(dataMaxTimestamp, time);
                        validDataRangeFound = true;
                    }
                });

                // Proceed with check only if a valid range was found in current data
                if (validDataRangeFound && isFinite(dataMinTimestamp) && isFinite(dataMaxTimestamp)) {
                    // Add a small tolerance (e.g., 1 minute) to avoid re-fetching when zoomed *exactly* to bounds
                    const tolerance = 60 * 1000; // 1 minute
                    const targetMinWithTolerance = initialTargetMin + tolerance;
                    const targetMaxWithTolerance = initialTargetMax - tolerance;

                    const isContained = targetMinWithTolerance >= dataMinTimestamp && targetMaxWithTolerance <= dataMaxTimestamp;

                    // Check if zooming past the end, but starting within
                    const startsWithinCurrentData = initialTargetMin >= dataMinTimestamp - tolerance; // Allow slight overlap
                    const endsBeyondCurrentData = initialTargetMax > dataMaxTimestamp + tolerance; // Check beyond tolerance

                    if (isContained) {
                        console.log(`Containment Check: Target is fully within current data range (with tolerance). Skipping fetch.`);
                        needsFetch = false;
                         // Update range display to show the currently displayed range, not the requested zoom range
                         displayActualRange(currentData);
                    } else if (startsWithinCurrentData && endsBeyondCurrentData) {
                         // This covers zooming further into the future beyond the last data point
                         console.log(`Containment Check: Target zooms past end of data but starts within. Skipping fetch.`);
                         needsFetch = false;
                         // Update range display to show the currently displayed range
                         displayActualRange(currentData);
                    } else {
                        // All other cases (panning left, zooming out, panning right beyond current data) require a fetch.
                        console.log(`Containment Check: Target is outside current data range (not just future zoom). Fetch required.`);
                        needsFetch = true;
                    }
                } else {
                    console.log("Containment Check: Not enough data points in current view. Fetch required.");
                    needsFetch = true;
                }
            } else {
                console.log("Containment Check: Not enough data points. Fetch required.");
                needsFetch = true;
            }

            // Exit now if the checks determined no fetch is needed
            if (!needsFetch) {
                 console.log("Fetch skipped based on containment/future-zoom check.");
                 return;
            }

            // --- Step 3: Perform Fetch ---
            console.log("Proceeding to fetch data for zoom/pan range.");
            const startTimeIso = new Date(initialTargetMin).toISOString();
            const endTimeIso = new Date(initialTargetMax).toISOString();
            console.log(`Fetching data for range: ${startTimeIso} to ${endTimeIso}`);
            const chartData = await fetchDataForRange(selectedGenerator, startTimeIso, endTimeIso); // Use dedicated range fetcher

            if (chartData === null) {
                console.error("fetchDataForRange returned null (error). Aborting update.");
                // The error status is already set by fetchDataForRange
                return; // Stop processing if fetch failed
            }

            // --- Step 4: Process fetch result ---
            console.log("Processing fetched data.");
            try {
                // Merge new data with existing data if desired, or replace.
                // Replacing is simpler and often sufficient for dense time series. Let's replace.
                // If merging were needed, you'd combine currentData and chartData, sort, and remove duplicates.
                powerChart.data.datasets[0].data = chartData; // Replace with newly fetched data

                if (chartData.length > 0) {
                    console.log(`Applying ${chartData.length} fetched points.`);

                    // Adjust scales based on the *requested* zoom range, not the fetched data range.
                    // This ensures the chart remains focused on where the user zoomed/panned.
                    chart.options.scales.x.min = initialTargetMin; // Use the requested start time
                    chart.options.scales.x.max = initialTargetMax; // Use the requested end time

                } else {
                     // API returned an empty array for the fetched range
                     console.log("API returned no data for the fetched range. Chart data is now empty.");
                     // Keep the scales where the user zoomed/panned to see the empty range.
                     // Scales already match the requested range (initialTargetMin/Max).
                }

                // Update chart *without* animation after zoom/pan fetch
                console.log("Calling chart update directly ('none') after processing fetch.");
                powerChart.update('none');
                console.log("Direct chart update completed.");
                displayActualRange(chartData); // Update range display based on *fetched* data (or empty message)


            } catch (error) {
                console.error("Error processing fetched data / adjusting scales:", error);
                updateStatus("Error updating chart after zoom/pan", true, 'chart'); // Chart status
            }

            console.log("handleZoomPanFetch function completed.");
        }

		// Create a debounced version of the zoom/pan fetch handler
        const debouncedZoomPanFetch = debounce(handleZoomPanFetch, ZOOM_PAN_DEBOUNCE_MS);

        // --- Event Listeners ---

        // Generator selection triggers data fetch (resetting zoom)
        generatorSelect.addEventListener('change', (event) => {
            const selectedValue = event.target.value;
            if (selectedValue) {
                console.log(`Generator selected: ${selectedValue} - Fetching data...`);
                updateChartWithApiData(true); // Fetch data and RESET zoom
                // The displayGeneratorInfo call is now inside updateChartWithApiData
            } else {
                console.log("Placeholder selected (Generator), clearing chart data and info.");
                if (powerChart) {
                    powerChart.data.datasets[0].data = [];
                    powerChart.options.plugins.title.text = `Battery Power: N/A`; // Reset title
                    delete powerChart.options.scales.x.min; // Reset zoom on deselect
                    delete powerChart.options.scales.x.max;
                    powerChart.update();
                }
                updateStatus("Select a Generator to view chart data.", false, 'chart'); // Chart status
                actualRangeDisplay.textContent = ''; // Clear range display
				displayGeneratorInfo(null); // Hide generator info section
            }
        });

        // NEW: Battery Info selection triggers displaying info
        batteryInfoSelect.addEventListener('change', (event) => {
             const selectedSiteName = event.target.value;
             console.log(`Battery Info Site selected: ${selectedSiteName}`);
             displayAllBatteryInfo(selectedSiteName);
        });


        // Time range mode change triggers data fetch (resetting zoom)
        timeRangeModeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                const isRelative = (this.value === 'relative');
                relativeTimeControls.style.display = isRelative ? 'flex' : 'none'; // Use flex for control-group
                absoluteTimeControls.style.display = isRelative ? 'none' : 'grid';

                if(generatorSelect.value) { // Only fetch if a generator is selected for the chart
                    updateChartWithApiData(true); // Fetch data and RESET zoom
                }
            });
        });

        // Helper to check if both absolute dates are validly set
        const areAbsoluteDatesSet = () => startTimeInput.value && endTimeInput.value;

        // Relative time range selection triggers data fetch (resetting zoom)
        timeRangeSelect.addEventListener('change', () => {
            if(generatorSelect.value) { updateChartWithApiData(true); }
        });

        // Absolute time changes trigger data fetch (resetting zoom)
        startTimeInput.addEventListener('change', () => {
            if(generatorSelect.value && areAbsoluteDatesSet()) { updateChartWithApiData(true); }
        });
        endTimeInput.addEventListener('change', () => {
            if(generatorSelect.value && areAbsoluteDatesSet()) { updateChartWithApiData(true); }
        });

		// --- Initial Setup ---
         document.addEventListener('DOMContentLoaded', async () => {
             console.log("DOM fully loaded - initializing...");

             // Initialize chart - already happens with new Chart(...)

             // Set initial state for time controls
             const initialTimeMode = document.querySelector('input[name="timeRangeMode"]:checked').value;
             relativeTimeControls.style.display = (initialTimeMode === 'relative') ? 'flex' : 'none'; // Use flex for control-group
             absoluteTimeControls.style.display = (initialTimeMode === 'absolute') ? 'grid' : 'none';

             // Set loading states for both dropdowns initially
             generatorSelect.innerHTML = '<option value="">Loading Generators...</option>'; // Chart generator dropdown
             batteryInfoSelect.innerHTML = '<option value="">Loading Batteries...</option>'; // Battery Info dropdown

             updateStatus("Loading initial data...", false, 'chart'); // Chart status
             updateStatus("Loading battery list...", false, 'batteryInfo'); // Battery Info status
             showLoading(true, "initial data"); // Chart loading
             showBatteryInfoLoading(true); // Battery Info loading

             try {
                 // Fetch generator list and battery metadata concurrently
                 const [generatorDuidList] = await Promise.all([
                     fetchGeneratorTags(),    // Fetches and returns the DUID list (or null on error)
                     fetchBatteryMetadata()   // Fetches, populates allBatteryDataArray and batteryMetadataMap (returns undefined)
                 ]);

                 // --- Populate Generator Dropdown (Chart) ---
                 generatorSelect.innerHTML = ''; // Clear loading message
                 if (generatorDuidList && Array.isArray(generatorDuidList)) {
                     const defaultOption = document.createElement('option');
                     defaultOption.value = "";
                     defaultOption.textContent = "-- Select Generator --";
                     generatorSelect.appendChild(defaultOption);

                     let populatedCount = 0;
                     generatorDuidList.forEach(duid => {
                         const metadata = batteryMetadataMap.get(duid);
                         // Use Site Name from metadata if available, otherwise fall back to DUID
                         const displayText = metadata?.['Site Name'] || duid;

                         const option = document.createElement('option');
                         option.value = duid; // IMPORTANT: Value remains the DUID for fetching chart data
                         option.textContent = displayText; // Display text is the Site Name (or DUID fallback)
                         generatorSelect.appendChild(option);
                         populatedCount++;
                     });

                     if (populatedCount > 0) {
                        updateStatus(`Generator list loaded (${populatedCount} found). Select one to view chart.`, false, 'chart');
                     } else if (generatorDuidList.length > 0) {
                        // DUIDs fetched, but maybe none matched metadata (unlikely with fallback)
                        updateStatus("Generator list loaded, but issue displaying names. Select one.", true, 'chart'); // Indicate potential issue
                     } else {
                        updateStatus("No dispatching generators found in the list from the API.", false, 'chart');
                     }
                 } else {
                     console.error("Failed to get a valid generator DUID list.");
                     generatorSelect.innerHTML = '<option value="">-- Error Loading List --</option>';
                     // Error status already set by fetchGeneratorTags
                 }

                 // --- Populate Battery Info Dropdown (JSON) ---
                 batteryInfoSelect.innerHTML = ''; // Clear loading message
                 if (allBatteryDataArray.length > 0) {
                      const defaultOption = document.createElement('option');
                      defaultOption.value = "";
                      defaultOption.textContent = "-- Select Battery For Info --";
                      batteryInfoSelect.appendChild(defaultOption);

                      allBatteryDataArray.forEach(battery => {
                          const siteName = battery['Site Name'];
                          if (siteName && typeof siteName === 'string' && siteName.trim() !== '') { // Ensure Site Name is valid
                               const option = document.createElement('option');
                               option.value = siteName.trim(); // Value is the Site Name
                               option.textContent = siteName.trim(); // Display text is the Site Name
                               batteryInfoSelect.appendChild(option);
                          }
                      });
                       updateStatus(`Battery list loaded (${allBatteryDataArray.length} found). Select one for details.`, false, 'batteryInfo'); // Battery info status
                 } else {
                      console.warn("No battery metadata loaded or array is empty.");
                      batteryInfoSelect.innerHTML = '<option value="">-- No Batteries Found --</option>';
                      // Error status already set by fetchBatteryMetadata if it failed
                      if (!batteryInfoStatus.textContent.includes("Error")) { // Avoid overwriting specific fetch error
                           updateStatus("Could not load battery list from metadata file.", true, 'batteryInfo'); // Battery info status
                      }
                 }


             } catch (error) {
                 // Catch potential errors from Promise.all itself (less likely now with individual fetch error handling)
                 console.error("Error during initial data loading:", error);
                 // Ensure statuses are updated if individual fetches didn't catch it
                 if (!statusDiv.textContent.includes("Error")) updateStatus("Failed during initial load.", true, 'chart');
                 if (!batteryInfoStatus.textContent.includes("Error")) updateStatus("Failed during initial load.", true, 'batteryInfo');
                 // Ensure dropdowns show error state if not already set
                 if(generatorSelect.options.length <= 1 && !generatorSelect.value) generatorSelect.innerHTML = '<option value="">-- Error --</option>';
                 if(batteryInfoSelect.options.length <= 1 && !batteryInfoSelect.value) batteryInfoSelect.innerHTML = '<option value="">-- Error --</option>';

             } finally {
                 showLoading(false); // Hide chart loading spinner
                 showBatteryInfoLoading(false); // Hide battery info loading spinner
             }
         });

    </script>
    <script data-goatcounter="https://batterywatch.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>