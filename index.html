<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battery Watch</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”‹</text></svg>" type="image/svg+xml">
    <style>
        /* --- Dark Theme CSS --- */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #383838;
            --chart-area-bg: #333333;
            --border-color: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --accent-primary: #007bff;
            --accent-hover: #0056b3;
            --disabled-bg: #555555;
            --disabled-text: #999999;
            --error-color: #f44336;
            --chart-grid-color: rgba(255, 255, 255, 0.15);
            --zero-line-color: rgba(255, 255, 255, 0.3);
            --chart-line-grey: #B0BEC5;
            --discharge-point-color: #64B5F6;
            --charge-point-color: #1976D2;
        }

        body {
            font-family: sans-serif;
            padding: 15px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.95em;
        }
        .container {
            /*max-width: 1200px;*/
            margin: 0 auto;
            /*background-color: var(--bg-secondary);*/
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
        }

        /* --- Centering --- */
        .header-section {
             text-align: center;
             margin-bottom: 25px;
        }
        .header-section h1 {
            margin-bottom: 5px;
        }
        .header-section p {
             margin-top: 0;
        }
        /* --- End Centering --- */

        h1, h2 { /* Removed unused h3 style */
            color: var(--text-primary);
        }
        p {
            color: var(--text-secondary);
        }

        .chart-container {
            position: relative;
            margin: 20px 0;
            height: 55vh;
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        .chart-container canvas {
             background-color: var(--chart-area-bg);
             border-radius: 3px;
             display: block;
             width: 100% !important;
             height: 100% !important;
        }

        .control-section {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        .control-section h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px 20px;
            align-items: center;
			justify-content: center; 
        }
		.control-group {
			 margin-bottom: 10px;
			 display: flex;         /* ADD: Make this a flex container */
			 align-items: center;   /* ADD: Vertically align items in the center */
			 /* flex-wrap: nowrap; */ /* Optional: Add if items still wrap unexpectedly */
			 justify-content: center; 
		}
		.control-group label {
			display: inline-block;
			margin-right: 8px;
			font-weight: bold;
			min-width: 80px; /* Keep this for consistent label width */
			color: var(--text-primary);
			vertical-align: middle; /* ADD or ENSURE this line exists */
		 }
		.control-group input[type="datetime-local"],
		 .control-group select {
			padding: 6px 8px;
			border: 1px solid var(--border-color);
			border-radius: 3px;
			box-sizing: border-box;
			background-color: var(--bg-tertiary);
			color: var(--text-primary);
			width: auto; /* Keep width auto */
			max-width: 200px; /* Adjust max-width if needed */
			vertical-align: middle; /* ADD or ENSURE this line exists */
		}
		
		#relativeTimeControls {
			display: flex !important;     /* Use !important to override inline style */
			align-items: center !important; /* Ensure vertical alignment */
		}
        .control-group input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }
        .control-group select {
            width: auto;
            max-width: 200px;
        }
        /* Removed unused checkbox style */

        /* Base button style (kept for potential future use, e.g., inside controls) */
        button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--accent-primary);
            color: white;
            margin: 5px;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            cursor: not-allowed;
        }
        /* Removed unused action-buttons styles */

        .status-and-loading {
            text-align: center;
            /*margin-top: 15px;*/
            min-height: 1.2em; /* Reserve space */
			margin-bottom: 10px;
        }
        #status {
             font-style: italic;
             color: var(--text-secondary);
             display: inline;
         }
        #status[style*="color: red"] { /* For error messages */
             color: var(--error-color) !important;
        }
        #loadingSpinner {
            display: none; /* Controlled by JS */
            font-weight: bold;
            color: var(--accent-primary);
            margin-left: 10px;
        }
        #actualRangeDisplay {
            text-align: center;
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 5px;
            min-height: 1.1em;
        }

        /* Style for Zoom Instructions */
        .zoom-instructions {
            text-align: center;
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: -10px;
            margin-bottom: 15px;
        }
        #batteryInfoContainer {
            /* Uses existing .control-section styles */
            /* Add specific overrides or additions if needed */
        }

        #batteryInfoContent table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        #batteryInfoContent th,
        #batteryInfoContent td {
            border: 1px solid var(--border-color);
            padding: 8px 10px;
            text-align: left;
            font-size: 0.9em;
        }

        #batteryInfoContent th {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
            width: 35%; /* Adjust width as needed */
        }

        #batteryInfoContent td {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
        }
		/* --- Footer Styling --- */
		footer {
			margin-top: 20px;       /* Space above the footer */
			padding: 20px var(--edge-padding); /* Vertical padding + Respect horizontal edge padding */
			border-top: 1px solid var(--card-border); /* Subtle divider using theme border color */
			text-align: center;      /* Center the text content */
			font-size: 0.9em;        /* Slightly smaller than base text */
			color: #aaa; /* Use the dimmer text color for less emphasis */
			/* Inherits background-color from body */
			/* Transition for smooth theme changes */
			transition: border-color 0.3s ease, color 0.3s ease;
		}
		footer p {
			margin: 0; /* Remove default paragraph margin */
		}

		footer a {
			color: #5dade2; /* Use the theme's link color */
			text-decoration: none;   /* Remove default underline */
			font-weight: 500;        /* Slightly bolder link */
			transition: color 0.2s ease; /* Smooth hover effect */
		}

		footer a:hover,
		footer a:focus {
			color: #5dade2; /* Keep color, or adjust if desired */
			text-decoration: underline; /* Add underline on hover/focus for accessibility */
			opacity: 0.85; /* Optional: Slight fade effect on hover */
		}
		
    </style>
</head>
<body>

<div class="container">
    <div class="header-section">
        <h1>Battery Watch</h1>
        <p>Select a battery and time range to explore the historical power output, and battery details. Only dispatching batteries are shown.</p>
    </div>

    <div class="control-section">

        <div class="control-grid">


			
            <!-- Battery Selector -->
            <div class="control-group">
                 <label for="tagValue">Battery:</label>
                 <select id="tagValue">
                     <option value="">Loading...</option>
                 </select>
            </div>
			<div class="status-and-loading">
				<span id="status">Select a battery to load data.</span>
				<span id="loadingSpinner"></span>
			</div>
            <!-- Relative Time Controls (Always Visible - styled as a grid item) -->
            <div id="relativeTimeControls" class="control-group">
                <label for="timeRange">Time Range:</label>
                <select id="timeRange">
                    <option value="1h">Last 1 Hour</option>
                    <option value="6h">Last 6 Hours</option>
                    <option value="12h">Last 12 Hours</option>
                    <option value="24h" selected>Last 24 Hours</option>
                    <option value="7d">Last 7 Days</option>
                    <option value="30d">Last 30 Days</option>
                </select>
            </div>

            <!-- Time Range Mode (HIDDEN but present for JS) -->
            <div style="display: none;"> <!-- Hide this whole div -->
                 <label><input type="radio" name="timeRangeMode" value="relative" checked> Relative</label>
                 <label><input type="radio" name="timeRangeMode" value="absolute"> Absolute</label>
            </div>
			
            <!-- Absolute Time Controls (HIDDEN but present for JS) -->
            <div id="absoluteTimeControls" style="display: none;"> <!-- Hide this whole div -->
                <div class="control-grid"> <!-- Nested grid still useful if shown -->
                    <div class="control-group">
                        <label for="startTime">Start Time:</label>
                        <input type="datetime-local" id="startTime">
                    </div>
                    <div class="control-group">
                         <label for="endTime">End Time:</label>
                        <input type="datetime-local" id="endTime">
                    </div>
                 </div>
                 <p style="text-align: center; font-size: 0.85em; color: var(--text-secondary); margin-top: 5px;">(Times use your browser's local timezone)</p>
            </div>

        </div> <!-- End control-grid -->
    </div> 
	
    <!-- Chart Display Area -->
    <div class="chart-container">
        <canvas id="powerChart"></canvas>
    </div>
    <p class="zoom-instructions">
        Tip: Double-click chart to reset zoom. Hold Ctrl + Drag to select zoom area. Use scroll wheel/pinch to zoom.<br>
        Zooming/panning will fetch data for the new visible range.
    </p>
    <div id="actualRangeDisplay" style="display: none;"></div><!-- Hide this whole div -->

    <div id="batteryInfoContainer" class="control-section" style="display: none; margin-top: 20px;">
        <h2>Battery Information</h2>
        <div id="batteryInfoContent">
            <!-- Content will be populated by JS -->
            <p>Loading battery details...</p>
        </div>
    </div>

</div> <!-- End Container -->
    <footer>
      <p>
        Made by Daniel Jurcola,
        <a href="https://www.linkedin.com/in/djurcola/" target="_blank" rel="noopener noreferrer">get in touch!</a>
      </p>
    </footer>


    <!-- Include Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <script>
        // --- UI Elements ---
        const generatorSelect = document.getElementById('tagValue');
        const timeRangeModeRadios = document.querySelectorAll('input[name="timeRangeMode"]');
        const relativeTimeControls = document.getElementById('relativeTimeControls');
        const absoluteTimeControls = document.getElementById('absoluteTimeControls');
        const timeRangeSelect = document.getElementById('timeRange');
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');
        const statusDiv = document.getElementById('status');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const actualRangeDisplay = document.getElementById('actualRangeDisplay');
		const batteryInfoContainer = document.getElementById('batteryInfoContainer');
		const batteryInfoContent = document.getElementById('batteryInfoContent');

        // --- CSS Variables ---
        const cssRoot = document.documentElement;
        const themeColors = {
            textPrimary: getComputedStyle(cssRoot).getPropertyValue('--text-primary').trim(),
            textSecondary: getComputedStyle(cssRoot).getPropertyValue('--text-secondary').trim(),
            chartGridColor: getComputedStyle(cssRoot).getPropertyValue('--chart-grid-color').trim(),
            zeroLineColor: getComputedStyle(cssRoot).getPropertyValue('--zero-line-color').trim(),
            chartLineGrey: getComputedStyle(cssRoot).getPropertyValue('--chart-line-grey').trim(),
            dischargePointColor: getComputedStyle(cssRoot).getPropertyValue('--discharge-point-color').trim(),
            chargePointColor: getComputedStyle(cssRoot).getPropertyValue('--charge-point-color').trim(),
        };

        // --- State Variables ---
        // let zoomPanFetchTimeoutId = null; // Not strictly necessary as debounce handles its own timer
        const ZOOM_PAN_DEBOUNCE_MS = 250;
		let batteryMetadataMap = new Map(); // To store BatteryData.json keyed by DUID
		
        // --- Helper Functions ---
        function showLoading(isLoading, operation = "data") {
            loadingSpinner.textContent = isLoading ? `Loading ${operation}...` : '';
            loadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
        }

        function updateStatus(message, isError = false) {
             statusDiv.textContent = message;
             statusDiv.style.color = isError ? 'var(--error-color)' : 'var(--text-secondary)';
             if (isError) console.error("Status Update (Error):", message);
         }

        // Debounce function (unchanged)
        function debounce(func, wait) {
            let timeout;
            const debounced = function executedFunction(...args) {
                const context = this;
                const later = () => {
                    timeout = null;
                    func.apply(context, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
            debounced.cancel = function() {
                clearTimeout(timeout);
                timeout = null;
            };
            return debounced;
        }
        // --- End Helper Functions ---

        // --- Chart.js Setup ---
        const ctx = document.getElementById('powerChart').getContext('2d');
        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Generator Output (MW)',
                    data: [],
                    borderColor: themeColors.chartLineGrey,
                    borderWidth: 2.5,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: (context) => {
                        const y = context.raw?.y;
                        if (y === null || y === undefined) return 'rgba(128, 128, 128, 0.5)';
                        return y < 0 ? themeColors.chargePointColor : themeColors.dischargePointColor;
                    },
                    pointBorderColor: (context) => {
                         const y = context.raw?.y;
                         if (y === null || y === undefined) return 'rgba(128, 128, 128, 0.8)';
                         return y < 0 ? themeColors.chargePointColor : themeColors.dischargePointColor;
                    },
                    pointBorderWidth: 1,
                    //tension: 0.1,
		    stepped: 'before',	
                    fill: false,
                    spanGaps: false,
                }]
             },
            options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 scales: {
                    x: {
                        type: 'time',
                        title: { display: true, text: 'Time', color: themeColors.textPrimary },
                        grid: { color: themeColors.chartGridColor },
                        ticks: { color: themeColors.textPrimary, major: { enabled: true } },
                        time: { // Define desired time formats
                            tooltipFormat: 'MMM d, yyyy HH:mm:ss', // Example format
                             displayFormats: {
                                millisecond: 'HH:mm:ss.SSS',
                                second: 'HH:mm:ss',
                                minute: 'HH:mm',
                                hour: 'HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy',
                                quarter: 'QQQ yyyy',
                                year: 'yyyy'
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Output (MW)', color: themeColors.textPrimary },
                        grid: { color: themeColors.chartGridColor },
                        ticks: { color: themeColors.textPrimary }
                    }
                 },
                 plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    title: {
                        display: true,
                        text: 'Battery Power Output',
                        font: { size: 16 },
                        color: themeColors.textPrimary
                    },
                    legend: {
                        display: true,
                        labels: { color: themeColors.textPrimary }
                    },
                    zoom: { // Zoom/Pan configuration (unchanged logic)
                        pan: {
                            enabled: true,
                            mode: 'x',
                            threshold: 5,
                            onPanComplete: ({chart}) => {
                                console.log("Pan complete");
                                debouncedZoomPanFetch(chart);
                            }
                        },
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            drag: {
                                enabled: true,
                                borderColor: 'rgba(173, 216, 230, 0.6)',
                                borderWidth: 1,
                                backgroundColor: 'rgba(173, 216, 230, 0.2)',
                                modifierKey: 'ctrl'
                            },
                            mode: 'x',
                            onZoomComplete: ({chart}) => {
                                console.log("Zoom complete");
                                debouncedZoomPanFetch(chart);
                            }
                        }
                    },
					annotation: { // Annotation configuration (unchanged logic)
                        annotations: {
                            zeroLine: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: themeColors.zeroLineColor,
                                borderWidth: 1.5,
                                borderDash: [6, 6],
                                label: {
                                    content: '0 MW',
                                    position: 'start',
                                    enabled: true,
                                    color: themeColors.textSecondary,
                                    font: { size: 10 },
                                    yAdjust: -5
                                }
                            }
                        }
                    }
                 },
                 interaction: { // Interaction configuration (unchanged logic)
                     mode: 'nearest',
                     axis: 'x',
                     intersect: false
                 }
            }
        };
        const powerChart = new Chart(ctx, chartConfig);

        // --- Double Click Reset Listener ---
        if (powerChart && powerChart.canvas) {
            powerChart.canvas.addEventListener('dblclick', () => {
                console.log("Chart canvas double-clicked - Resetting zoom and fetching initial range data.");
                powerChart.resetZoom(); // Reset zoom state

                // Cancel any pending zoom/pan fetch that might have been queued by the resetZoom()
                debouncedZoomPanFetch.cancel();
                console.log("Cancelled any pending zoom/pan fetch due to reset.");

                // Fetch data based on UI controls after resetting zoom
                updateChartWithApiData(true); // Pass flag to indicate explicit reset
            });
        } else {
            console.error("Could not attach double-click listener: Chart or canvas not ready.");
        }

        // --- API Communication ---
        const API_BASE_URL = 'https://backend.danjurcola.com/api';
        const API_GENERATORS_ENDPOINT = `${API_BASE_URL}/generators`;
        const API_QUERY_ENDPOINT = `${API_BASE_URL}/query`;
		const BATTERY_DATA_URL = './BatteryData.json';
		//const BATTERY_DATA_URL = 'https://raw.githubusercontent.com/djurcola/BatteryWatch/refs/heads/main/BatteryData.json';
		
		async function fetchBatteryMetadata() {
			console.log("Fetching battery metadata...");
			updateStatus("Loading battery metadata..."); // Temporary status update
			try {
				const response = await fetch(BATTERY_DATA_URL);
				if (!response.ok) {
					throw new Error(`HTTP error ${response.status} fetching ${BATTERY_DATA_URL}`);
				}
				const batteryDataArray = await response.json();

				if (Array.isArray(batteryDataArray)) {
					batteryMetadataMap.clear(); // Clear previous data if any
					batteryDataArray.forEach(item => {
						// Use DUID as the key. Handle cases where DUID might be empty or null.
						if (item.DUID && typeof item.DUID === 'string' && item.DUID.trim() !== '') {
							batteryMetadataMap.set(item.DUID.trim(), item);
						} else {
							// Optionally log assets without a DUID if needed for debugging
							// console.warn("Skipping battery metadata entry with missing/empty DUID:", item['Site Name']);
						}
					});
					console.log(`Successfully loaded and mapped ${batteryMetadataMap.size} battery metadata entries.`);
					// Status will be updated later by generator selection or initial load completion
				} else {
					throw new Error("Battery metadata file did not contain a valid JSON array.");
				}
			} catch (error) {
				console.error("Error fetching or processing battery metadata:", error);
				updateStatus(`Error loading battery metadata: ${error.message}`, true);
				batteryMetadataMap.clear(); // Ensure map is empty on error
				// We still allow the app to function for chart data even if metadata fails
			}
		}
		
		function displayBatteryInfo(generatorDUID) {
			if (!generatorDUID) {
				batteryInfoContainer.style.display = 'none'; // Hide if no generator selected
				batteryInfoContent.innerHTML = ''; // Clear content
				return;
			}
			const batteryData = batteryMetadataMap.get(generatorDUID);
			if (batteryData) {
				console.log("Found battery data for DUID:", generatorDUID, batteryData);
				// Select the fields you want to display
				const fieldsToShow = {
					'Site Name': 'Site Name',
					'Owner': 'Owner',
					'Region': 'Region',
					'Status': 'Unit Status',
					'Nameplate Capacity (MW)': 'Nameplate Capacity (MW)',
					'Storage Capacity (MWh)': 'Storage Capacity (MWh)',
					'Commercial Use Date': 'Full Commercial Use Date',
					'Battery Manufacturer': 'Battery Manufacturer',
					'Battery Model': 'Battery Model',
					'Inverter Manufacturer': 'Inverter Manufacturer',
					'Inverter Model': 'Inverter Model'
					// Add more fields here by specifying 'Display Label': 'JSON_Field_Name'
				};
				let tableHTML = '<table><tbody>';
				for (const [label, key] of Object.entries(fieldsToShow)) {
					const value = batteryData[key] !== null && batteryData[key] !== undefined && batteryData[key] !== '' ? batteryData[key] : 'N/A';
					tableHTML += `<tr><th>${label}</th><td>${value}</td></tr>`;
				}
				tableHTML += '</tbody></table>';
				batteryInfoContent.innerHTML = tableHTML;
				batteryInfoContainer.style.display = 'block'; // Show the container
			} else {
				console.log("No battery metadata found for DUID:", generatorDUID);
				batteryInfoContent.innerHTML = '<p>No additional battery information found for this generator.</p>';
				batteryInfoContainer.style.display = 'block'; // Show the container with the message
			}
		}


		async function fetchGeneratorTags() {
            // Don't update status or dropdown here directly
            // showLoading(true, "generators"); // Loading handled globally now
            // updateStatus("Fetching generator list...");
            // generatorSelect.innerHTML = '<option value="">Loading...</option>'; // Will be populated later

            try {
                const response = await fetch(API_GENERATORS_ENDPOINT);
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status} ${response.statusText}`);
                }
                const generatorList = await response.json();

                if (Array.isArray(generatorList)) {
                    console.log("Fetched generator DUID list:", generatorList.length, "items");
                    // Just return the list, filtering out empty values
                    return generatorList.filter(genName => genName).sort();
                } else {
                    throw new Error("API response for generators was not an array.");
                }
            } catch (error) {
                console.error("Error fetching generator tags:", error);
                updateStatus(`Error fetching generators: ${error.message}`, true);
                // Return null or an empty array to signal failure
                return null;
            }
            // No finally block needed here for showLoading, handled globally
        }

        // Fetch Function for specific time range (used by zoom/pan)
        async function fetchDataForRange(generator, startTimeIso, endTimeIso) {
            if (!generator || !startTimeIso || !endTimeIso) {
                console.warn("fetchDataForRange called with missing parameters.");
                // Optionally update status or return specific error object if needed elsewhere
                return null;
            }

            const params = new URLSearchParams({
                generator: generator,
                timeMode: 'absolute', // Always use absolute for direct range fetches
                start: startTimeIso,
                end: endTimeIso
            });

            const queryUrl = `${API_QUERY_ENDPOINT}?${params.toString()}`;
            console.log(`Requesting data for specific range: ${queryUrl}`);
            showLoading(true, "data");
            updateStatus(`Fetching data for range: ${new Date(startTimeIso).toLocaleString()} - ${new Date(endTimeIso).toLocaleString()}`);

            try {
                const response = await fetch(queryUrl);
                 if (!response.ok) {
                     let errorDetail = `API Error: ${response.status} ${response.statusText}`;
                    try {
                        const errData = await response.json();
                        errorDetail += ` - ${errData.error || JSON.stringify(errData)}`;
                    } catch(e) { /* Ignore if response body isn't JSON */ }
                    throw new Error(errorDetail);
                }
                const apiData = await response.json();

                if (!Array.isArray(apiData)) {
                     throw new Error("API response for data was not an array.");
                }

                // Transform data for Chart.js {x: Date, y: number}
                const chartData = apiData.map(point => ({
                    x: new Date(point.x),
                    y: point.y
                })).filter(p => !isNaN(p.x.getTime())); // Filter out points with invalid dates

                updateStatus(`Data loaded: ${chartData.length} points for the selected range.`);
                displayActualRange(chartData); // Update the range display text

                return chartData; // Success

            } catch (error) {
                console.error('API Fetch Error (fetchDataForRange):', error);
                updateStatus(`Error fetching data for range: ${error.message}`, true);
                actualRangeDisplay.textContent = ''; // Clear range display on error
                return null; // Indicate failure
            } finally {
                showLoading(false); // Hide loading indicator
            }
        }

        // Fetch data based on UI controls (Relative/Absolute Time)
        async function fetchDataFromApi() {
            const selectedGenerator = generatorSelect.value;
            const timeMode = document.querySelector('input[name="timeRangeMode"]:checked').value;

            actualRangeDisplay.textContent = ''; // Clear previous range display
            showLoading(true);
            updateStatus("Fetching data based on controls...");

            if (!selectedGenerator) {
                 updateStatus("Error: Please select a Generator.", true);
                 showLoading(false);
                 return null;
            }

            const params = new URLSearchParams({
                 generator: selectedGenerator,
                 timeMode: timeMode
            });
            let startIso, endIso; // Define here for absolute mode

            if (timeMode === 'relative') {
                const range = timeRangeSelect.value;
                if (!range) {
                    updateStatus("Error: Invalid relative range selected.", true);
                    showLoading(false);
                    return null;
                }
                params.append('range', range);
            } else { // Absolute time
                const start = startTimeInput.value;
                const end = endTimeInput.value;
                if (!start || !end) {
                     updateStatus("Error: Please select both Start and End times.", true);
                     showLoading(false);
                     return null;
                }
                try {
                    // Convert local datetime-local input to ISO strings for the API
                    startIso = new Date(start).toISOString();
                    endIso = new Date(end).toISOString();
                    params.append('start', startIso);
                    params.append('end', endIso);
                } catch (e) {
                     updateStatus("Error: Invalid date format entered.", true);
                     showLoading(false);
                     console.error("Error parsing absolute dates:", e);
                     return null;
                }
            }

            const queryUrl = `${API_QUERY_ENDPOINT}?${params.toString()}`;
            console.log(`Requesting data from API (UI controls): ${queryUrl}`);

            try {
                const response = await fetch(queryUrl);
                 if (!response.ok) {
                     let errorDetail = `API Error: ${response.status} ${response.statusText}`;
                    try {
                        const errData = await response.json();
                        errorDetail += ` - ${errData.error || JSON.stringify(errData)}`;
                    } catch(e) { /* Ignore */ }
                    throw new Error(errorDetail);
                }
                const apiData = await response.json();

                if (!Array.isArray(apiData)) {
                     throw new Error("API response for data was not an array.");
                }

                // Transform data for Chart.js
                const chartData = apiData.map(point => ({
                    x: new Date(point.x),
                    y: point.y
                })).filter(p => !isNaN(p.x.getTime()));

                updateStatus(`Data loaded: ${chartData.length} points.`);
                displayActualRange(chartData); // Update the range display text

                return chartData; // Success

            } catch (error) {
                console.error('API Fetch Error (fetchDataFromApi):', error);
                updateStatus(`Error fetching data: ${error.message}`, true);
                actualRangeDisplay.textContent = '';
                return null; // Indicate failure
            } finally {
                 showLoading(false);
            }
        }

        // Helper to update the actual range display text
        function displayActualRange(chartData) {
            if (chartData && chartData.length > 0) {
                 const firstPoint = chartData[0];
                 const lastPoint = chartData[chartData.length - 1];
                 // Check if points and their dates are valid
                 if (firstPoint?.x instanceof Date && !isNaN(firstPoint.x.getTime()) &&
                     lastPoint?.x instanceof Date && !isNaN(lastPoint.x.getTime()))
                 {
                     const formatConfig = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' };
                     // Display range based on actual data points returned
                     actualRangeDisplay.textContent = `Data displayed from: ${firstPoint.x.toLocaleString(undefined, formatConfig)} to ${lastPoint.x.toLocaleString(undefined, formatConfig)}`;
                 } else {
                      actualRangeDisplay.textContent = 'Could not determine data range from points.';
                      console.warn("displayActualRange: Invalid date found in first/last point", firstPoint, lastPoint);
                 }
            } else {
                actualRangeDisplay.textContent = 'No data returned for this period.';
            }
        }

        // Updates chart based on UI controls, optionally resetting zoom
        async function updateChartWithApiData(isReset = false) {
            const chartData = await fetchDataFromApi(); // Fetch based on UI

            if (!powerChart) { // Guard against chart not being ready
                console.error("updateChartWithApiData called before chart was initialized.");
                return;
            }

            if (chartData !== null) { // Check if fetch was successful (returned data or empty array)
                const selectedGenerator = generatorSelect.value;
                powerChart.data.datasets[0].data = chartData;
                //powerChart.data.datasets[0].label = `Output (MW)${selectedGenerator ? ` (${selectedGenerator})` : ''}`;
				powerChart.data.datasets[0].label = `Output (MW)${selectedGenerator ? ` `: ''}`;
                powerChart.options.plugins.title.text = `Battery Power: ${selectedGenerator || 'N/A'}`;

                // Reset zoom ONLY when called from UI changes/explicit reset, OR if not currently zoomed/panned
                if (isReset || !powerChart.isZoomedOrPanned()) {
                    console.log("Resetting chart zoom to fit fetched data.");
                    delete powerChart.options.scales.x.min; // Let Chart.js auto-scale
                    delete powerChart.options.scales.x.max;
                } else {
                    console.log("Maintaining current chart zoom level after UI-triggered fetch.");
                }

                powerChart.update(); // Use default update animation for UI-triggered changes
            } else {
                // Fetch failed (returned null)
                console.log("Clearing chart data due to fetch error or null data.");
                powerChart.data.datasets[0].data = [];
                powerChart.options.plugins.title.text = `Battery Power: ${generatorSelect.value || 'N/A'} (No data or error)`;
                // Always reset zoom on error to avoid being stuck in an invalid range
                delete powerChart.options.scales.x.min;
                delete powerChart.options.scales.x.max;
                powerChart.update();
            }
        }

        // Handles fetching data when zoom or pan completes. Logic is UNCHANGED from original working version.
        async function handleZoomPanFetch(chart) {
            const selectedGenerator = generatorSelect.value;
            if (!selectedGenerator) {
                console.log("Zoom/Pan fetch skipped: No battery selected.");
                return;
            }

            // --- Step 1: Read initial scales ---
            if (!chart?.scales?.x) {
                 console.error("handleZoomPanFetch Error: Chart scales object is not available.");
                 return;
            }
            const { min: initialTargetMin, max: initialTargetMax } = chart.scales.x;

            // Validate initial scales read from the event
            if (initialTargetMin === undefined || initialTargetMax === undefined || typeof initialTargetMin !== 'number' || typeof initialTargetMax !== 'number') {
                 console.warn("Zoom/Pan fetch skipped: Could not read valid min/max numbers from chart scales.", initialTargetMin, initialTargetMax);
                 return;
            }
            if (initialTargetMin >= initialTargetMax) {
                console.warn("Zoom/Pan fetch skipped: Invalid initial target time range (min >= max).", initialTargetMin, initialTargetMax);
                return;
            }

            // --- Step 2: Containment/Future Zoom Check --- (Original Logic)
            let needsFetch = true; // Assume fetch needed unless logic says otherwise
            const currentData = chart.data.datasets[0].data;

            if (currentData && currentData.length > 1) {
                let dataMinTimestamp = Infinity;
                let dataMaxTimestamp = -Infinity;
                let validDataRangeFound = false;

                // Find the actual min/max timestamps in the *currently displayed* data
                currentData.forEach(point => {
                    if (point?.x instanceof Date && !isNaN(point.x.getTime())) { // Use optional chaining and check Date instance
                        const time = point.x.getTime();
                        if (isFinite(time)) {
                             dataMinTimestamp = Math.min(dataMinTimestamp, time); // More efficient min/max
                             dataMaxTimestamp = Math.max(dataMaxTimestamp, time);
                             validDataRangeFound = true;
                        }
                    }
                });

                // Proceed with check only if a valid range was found in current data
                if (validDataRangeFound && isFinite(dataMinTimestamp) && isFinite(dataMaxTimestamp)) {
                    const targetMinDateStr = new Date(initialTargetMin).toISOString();
                    const targetMaxDateStr = new Date(initialTargetMax).toISOString();
                    const currentMinDateStr = new Date(dataMinTimestamp).toISOString();
                    const currentMaxDateStr = new Date(dataMaxTimestamp).toISOString();

                    console.log(`Containment Check: Current data range ${currentMinDateStr} - ${currentMaxDateStr}`);
                    console.log(`Containment Check: Target range ${targetMinDateStr} - ${targetMaxDateStr}`);

                    const isContained = initialTargetMin >= dataMinTimestamp && initialTargetMax <= dataMaxTimestamp;
                    // Original check for "zooming into future"
                    const startsWithinCurrentData = initialTargetMin >= dataMinTimestamp;
                    const endsBeyondCurrentData = initialTargetMax > dataMaxTimestamp;

                    if (isContained) {
                        console.log(`Containment Check: Target is fully within current data range. Skipping fetch.`);
                        needsFetch = false;
                    } else if (startsWithinCurrentData && endsBeyondCurrentData) {
                        // This was the specific check in the original code to skip fetching if zooming past the end
                        console.log(`Containment Check: Target zooms into future but starts within current data. Skipping fetch.`);
                        needsFetch = false;
                    } else {
                        // All other cases (panning left, zooming out, panning right beyond current data) require a fetch.
                        console.log(`Containment Check: Target is outside current data range (not just future zoom). Fetch required.`);
                        needsFetch = true;
                    }
                } else {
                    console.log("Containment Check: Could not determine valid range from current data. Fetch required.");
                    needsFetch = true;
                }
            } else {
                console.log("Containment Check: Not enough data points. Fetch required.");
                needsFetch = true;
            }

            // Exit now if the checks determined no fetch is needed
            if (!needsFetch) {
                 console.log("Fetch skipped based on containment/future-zoom check.");
                 return;
            }

            // --- Step 3: Perform Fetch ---
            console.log("Proceeding to fetch data.");
            const startTimeIso = new Date(initialTargetMin).toISOString();
            const endTimeIso = new Date(initialTargetMax).toISOString();
            console.log(`Fetching data for range: ${startTimeIso} to ${endTimeIso}`);
            const chartData = await fetchDataForRange(selectedGenerator, startTimeIso, endTimeIso);

            if (chartData === null) {
                console.error("fetchDataForRange returned null (error). Aborting update.");
                return; // Stop processing if fetch failed
            }

            // --- Step 4: Process fetch result --- (Original Logic)
            console.log("Processing fetched data.");
            try {
                // Assign the newly fetched data
                powerChart.data.datasets[0].data = chartData;
                powerChart.data.datasets[0].label = `Output (MW)${selectedGenerator ? ` (${selectedGenerator})` : ''}`;
                powerChart.options.plugins.title.text = `Battery Power: ${selectedGenerator || 'N/A'}`;

                // Original logic did have scale adjustment based on fetched data, let's keep it.
                if (chartData.length > 0) {
                    console.log(`Applying ${chartData.length} fetched points.`);

                    // Find the actual max timestamp from the *fetched* data
                    let actualMaxTimestamp = -Infinity;
                    let validPointFoundInFetchedData = false;
                    chartData.forEach(point => {
                         if (point?.x instanceof Date && !isNaN(point.x.getTime())) {
                             const time = point.x.getTime();
                             if (isFinite(time)) {
                                 actualMaxTimestamp = Math.max(actualMaxTimestamp, time);
                                 validPointFoundInFetchedData = true;
                             }
                         }
                    });

                    // Adjust scales based on fetched data's actual range
                    if (validPointFoundInFetchedData && isFinite(actualMaxTimestamp)) {
                        let finalMinScale = initialTargetMin; // Use the requested start time
                        // Clamp the max scale to the latest point actually returned by the fetch
                        const finalMaxScale = actualMaxTimestamp;

                        // Sanity check min < max
                        if (finalMinScale >= finalMaxScale) {
                             console.warn(`Scale adjustment conflict: Initial Target Min (${new Date(finalMinScale).toISOString()}) >= Fetched Data Max (${new Date(finalMaxScale).toISOString()}). Setting Min to Max - 1min.`);
                             finalMinScale = finalMaxScale - 60000; // Fallback: 1 minute before max
                        }

                        // Check if scales need changing from current state before modifying
                        // This comparison should use the chart's *current* scale values
                        if (chart.scales.x.min !== finalMinScale || chart.scales.x.max !== finalMaxScale) {
                            console.log(`Adjusting scales synchronously to fetched data range: ${new Date(finalMinScale).toISOString()} to ${new Date(finalMaxScale).toISOString()}`);
                            chart.options.scales.x.min = finalMinScale; // Set on options before update
                            chart.options.scales.x.max = finalMaxScale;
                        } else {
                             console.log("Scales already match target range after fetch, no adjustment needed.");
                        }
                    } else {
                         console.warn("No valid points found in fetched data to calculate scale adjustments.");
                         // If no valid points, don't adjust scales - keep the user's requested zoom window
                         // Resetting min/max here would be wrong, leave them as they are from the zoom event.
                         // delete chart.options.scales.x.min; // DO NOT DO THIS
                         // delete chart.options.scales.x.max; // DO NOT DO THIS
                    }
                } else {
                     // API returned an empty array for the fetched range
                     console.log("API returned no data for the fetched range. Chart data is now empty.");
                     // Keep the scales where the user zoomed/panned to see the empty range.
                     // No scale adjustment needed.
                }

                // Update chart *without* animation after zoom/pan fetch
                console.log("Calling chart update directly ('none') after processing fetch.");
                powerChart.update('none');
                console.log("Direct chart update completed.");

            } catch (error) {
                console.error("Error processing fetched data / adjusting scales:", error);
                // Potentially update status here as well
                updateStatus("Error updating chart after zoom/pan", true);
            }

            console.log("handleZoomPanFetch function completed.");
        }

		// Create a debounced version of the zoom/pan fetch handler
        const debouncedZoomPanFetch = debounce(handleZoomPanFetch, ZOOM_PAN_DEBOUNCE_MS);

        // --- Event Listeners ---

        // Generator selection triggers data fetch (resetting zoom)
        generatorSelect.addEventListener('change', (event) => {
            const selectedValue = event.target.value;
            if (selectedValue) {
                console.log(`Generator selected: ${selectedValue} - Fetching data...`);
                updateChartWithApiData(true); // Fetch data and RESET zoom
				displayBatteryInfo(selectedValue); // Display battery info using the selected DUID
            } else {
                console.log("Placeholder selected, clearing chart data.");
                if (powerChart) {
                    powerChart.data.datasets[0].data = [];
                    delete powerChart.options.scales.x.min; // Reset zoom on deselect
                    delete powerChart.options.scales.x.max;
                    powerChart.update();
                }
                updateStatus("Select a battery to view data.");
                actualRangeDisplay.textContent = '';
				displayBatteryInfo(null); // Hide battery info section
            }
        });

        // Time range mode change triggers data fetch (resetting zoom)
        timeRangeModeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                const isRelative = (this.value === 'relative');
                relativeTimeControls.style.display = isRelative ? 'grid' : 'none';
                absoluteTimeControls.style.display = isRelative ? 'none' : 'grid';

                if(generatorSelect.value) { // Only fetch if a generator is selected
                    updateChartWithApiData(true); // Fetch data and RESET zoom
                }
            });
        });

        // Helper to check if both absolute dates are validly set
        const areAbsoluteDatesSet = () => startTimeInput.value && endTimeInput.value;

        // Relative time range selection triggers data fetch (resetting zoom)
        timeRangeSelect.addEventListener('change', () => {
            if(generatorSelect.value) { updateChartWithApiData(true); }
        });

        // Absolute time changes trigger data fetch (resetting zoom)
        startTimeInput.addEventListener('change', () => {
            if(generatorSelect.value && areAbsoluteDatesSet()) { updateChartWithApiData(true); }
        });
        endTimeInput.addEventListener('change', () => {
            if(generatorSelect.value && areAbsoluteDatesSet()) { updateChartWithApiData(true); }
        });

		// --- Initial Setup ---
         document.addEventListener('DOMContentLoaded', async () => {
             console.log("DOM fully loaded - initializing...");

             // Initialize chart - already happens with new Chart(...)

             // Set initial state for time controls
             const initialTimeMode = document.querySelector('input[name="timeRangeMode"]:checked').value;
             relativeTimeControls.style.display = (initialTimeMode === 'relative') ? 'flex' : 'none'; // Use flex for control-group
             absoluteTimeControls.style.display = (initialTimeMode === 'absolute') ? 'grid' : 'none';

             updateStatus("Loading initial data..."); // Initial status message
             showLoading(true, "initial data"); // Show combined loading state
             generatorSelect.innerHTML = '<option value="">Loading...</option>'; // Set loading state for dropdown

             try {
                 // Fetch generator list and battery metadata concurrently
                 const [generatorDuidList, _metadataResult] = await Promise.all([
                     fetchGeneratorTags(),    // Fetches and returns the DUID list (or null on error)
                     fetchBatteryMetadata()   // Fetches and populates the batteryMetadataMap (returns undefined)
                 ]);

                 // --- Populate Dropdown AFTER both fetches complete ---
                 generatorSelect.innerHTML = ''; // Clear loading message

                 if (generatorDuidList && Array.isArray(generatorDuidList)) {
                     // Add the default placeholder option
                     const defaultOption = document.createElement('option');
                     defaultOption.value = "";
                     defaultOption.textContent = "-- Select Battery --";
                     generatorSelect.appendChild(defaultOption);

                     // Populate with Site Names
                     let populatedCount = 0;
                     generatorDuidList.forEach(duid => {
                         const metadata = batteryMetadataMap.get(duid);
                         // Use Site Name if available, otherwise fall back to DUID
                         const displayText = metadata?.['Site Name'] || duid;

                         const option = document.createElement('option');
                         option.value = duid; // IMPORTANT: Value remains the DUID
                         option.textContent = displayText; // Display text is the Site Name (or DUID fallback)
                         generatorSelect.appendChild(option);
                         populatedCount++;
                     });

                     if (populatedCount > 0) {
                        updateStatus(`Generator list loaded (${populatedCount} found). Select one.`);
                     } else if (generatorDuidList.length > 0) {
                        // DUIDs fetched, but maybe none matched metadata (unlikely with fallback)
                        updateStatus("Generator list loaded, but issue displaying names. Select one.", true); // Indicate potential issue
                     }
                      else {
                        updateStatus("No generators found in the list from the API.");
                     }

                 } else {
                     // fetchGeneratorTags must have returned null or invalid data
                     console.error("Failed to get a valid generator DUID list.");
                     generatorSelect.innerHTML = '<option value="">-- Error Loading List --</option>';
                     // Keep the error status set by fetchGeneratorTags if it failed
                     if (!statusDiv.textContent.includes("Error")) { // Avoid overwriting specific fetch error
                        updateStatus("Could not load generator list.", true);
                     }
                 }
                // If battery metadata fetch failed, its error message should persist if generators loaded ok.

             } catch (error) {
                 // Catch potential errors from Promise.all itself
                 console.error("Error during initial data loading:", error);
                 updateStatus("Failed to load initial page data. Check console.", true);
                 generatorSelect.innerHTML = '<option value="">-- Error --</option>';
             } finally {
                 showLoading(false); // Hide loading indicator regardless of success/error
             }
         });

    </script>
    <script data-goatcounter="https://batterywatch.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
